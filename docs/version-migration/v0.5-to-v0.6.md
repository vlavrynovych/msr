---
layout: default
title: v0.5.x ‚Üí v0.6.0
parent: Version Migration
nav_order: 1
---

# Migrating from v0.5.x to v0.6.0
{: .no_toc }

Guide for upgrading from v0.5.x to v0.6.0 of Migration Script Runner.
{: .fs-6 .fw-300 }

## Table of Contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Overview

v0.6.0 is a **major release with breaking changes** in the constructor signature. This release adds powerful generic type parameters throughout the API for database-specific type safety and improves the constructor with dependency injection pattern.

### What's New in v0.6.0

- ‚ú® **Generic Type Parameters** - Full type safety for database-specific operations
- üî® **Breaking Change: Constructor Signature** - Now uses `{ handler }` dependency injection pattern
- ‚ú® **Enhanced Type Guards** - Type-preserving runtime checks with `isImperativeTransactional<DB>()` and `isCallbackTransactional<DB>()`
- üéØ **IDE Autocomplete** - Full IntelliSense for database-specific methods
- üõ°Ô∏è **Compile-Time Validation** - Catch database errors at compile time, not runtime
- üîß **Auto-Config Loading** - Config parameter now optional (auto-loads if not provided)
- üìä **Metrics Collection** - New built-in metrics collectors (Console, Logger, Json, Csv) for observability

### Migration Effort

**Estimated Time**: 5-15 minutes to update constructor calls

**Complexity**: Low - Simple constructor signature change, rest is optional adoption

---

## Prerequisites

Before upgrading, ensure:

- You're currently on **v0.5.x**
- Your tests are passing
- You have TypeScript 4.5+ (for best generic inference)

---

## Upgrade Steps

### 1. Update Package

```bash
npm install @migration-script-runner/core@^0.6.0
```

Or with yarn:

```bash
yarn upgrade @migration-script-runner/core@^0.6.0
```

### 2. Update Constructor Calls

**REQUIRED:** Update all constructor calls to use the new dependency injection pattern:

#### BEFORE (v0.5.x):
```typescript
import { MigrationScriptExecutor, Config } from '@migration-script-runner/core';

const executor = new MigrationScriptExecutor(handler, config);
```

#### AFTER (v0.6.0):
```typescript
import { MigrationScriptExecutor, Config } from '@migration-script-runner/core';

const executor = new MigrationScriptExecutor({ handler }, config);
// Note: config is now optional - auto-loads if not provided
```

**Key Changes:**
- Handler must be wrapped in object: `{ handler }`
- Config is now second parameter (and optional)

### 3. Run Your Test Suite

```bash
npm test
```

All tests should pass after updating the constructor calls in Step 2.

### 4. Optional: Adopt Type Safety

v0.6.0 adds optional generic type parameters you can adopt at your own pace for enhanced type safety. See sections below for details.

---

## Breaking Changes

v0.6.0 includes **one breaking change** in the constructor signature:

### Constructor Signature Change

| Component | v0.5.x | v0.6.0 |
|-----------|--------|--------|
| **MigrationScriptExecutor** | `new MigrationScriptExecutor(handler, config)` | `new MigrationScriptExecutor({ handler }, config?)` |

**What Changed:**
- Handler is now required in a `dependencies` object as the first parameter
- Config is now the second parameter and is **optional** (auto-loads if not provided)

**Why:** This enables dependency injection and makes the API more extensible for future features.

### Generic Type Parameters (Non-Breaking)

All interfaces gained optional generic type parameters with default values:

| API | v0.5.x Signature | v0.6.0 Signature |
|-----|------------------|------------------|
| **IDatabaseMigrationHandler** | `interface IDatabaseMigrationHandler` | `interface IDatabaseMigrationHandler<DB extends IDB = IDB>` |
| **IRunnableScript** | `interface IRunnableScript` | `interface IRunnableScript<DB extends IDB = IDB>` |
| **MigrationScriptExecutor** | `class MigrationScriptExecutor` | `class MigrationScriptExecutor<DB extends IDB = IDB>` |
| **ISchemaVersion** | `interface ISchemaVersion` | `interface ISchemaVersion<DB extends IDB = IDB>` |
| **ITransactionManager** | `interface ITransactionManager` | `interface ITransactionManager<DB extends IDB = IDB>` |

**Default type parameter `= IDB`** ensures interface implementations work without modification (you only need to update constructor calls).

---

## What Are Generic Type Parameters?

Generic type parameters allow you to specify the **exact database type** throughout MSR's interfaces, giving you:

- **Full IDE autocomplete** for database-specific methods
- **Compile-time type checking** - catch errors before runtime
- **Self-documenting code** - types show what's available
- **No more `as any` casting** in migration scripts

### The Problem (v0.5.x)

```typescript
// v0.5.x - Limited type safety
interface IDatabaseMigrationHandler {
  db: IDB;  // Generic IDB type - no database-specific methods
}

// In migration script
const migration: IRunnableScript = {
  async up(db, info, handler) {
    // ‚ùå No autocomplete for PostgreSQL-specific methods
    // ‚ùå TypeScript doesn't know about query(), COPY, etc.
    await (db as any).query('SELECT * FROM users');  // Have to cast!
  }
};
```

### The Solution (v0.6.0)

```typescript
// v0.6.0 - Full type safety with generics
interface IDatabaseMigrationHandler<DB extends IDB = IDB> {
  db: DB;  // Specific database type (IPostgresDB, IMySQLDB, etc.)
}

// In migration script
const migration: IRunnableScript<IPostgresDB> = {
  async up(db, info, handler) {
    // ‚úÖ Full autocomplete for PostgreSQL methods
    // ‚úÖ TypeScript validates db.query() exists
    await db.query('SELECT * FROM users');  // No casting needed!
    await db.query('COPY users FROM STDIN');  // PostgreSQL-specific
  }
};
```

---

## Adoption Guide

You can adopt generics **incrementally** - no need to update everything at once.

### Step 1: Define Your Database Interface

Create a typed interface for your database:

```typescript
import { IDB, ITransactionalDB } from '@migration-script-runner/core';

// PostgreSQL example - ITransactionalDB already extends IDB
interface IPostgresDB extends ITransactionalDB {
  query<T = any>(sql: string, params?: any[]): Promise<T[]>;
  // Add other PostgreSQL-specific methods as needed
}

// MySQL example - ITransactionalDB already extends IDB
interface IMySQLDB extends ITransactionalDB {
  query(sql: string, values?: any[]): Promise<any>;
  execute(sql: string, values?: any[]): Promise<any>;
}

// MongoDB example - No transactions, extends IDB directly
interface IMongoDatabase extends IDB {
  collection(name: string): any;
  listCollections(): any;
}
```

### Step 2: Type Your Handler

Add the generic parameter to your handler:

#### BEFORE (v0.5.x)

```typescript
import { IDatabaseMigrationHandler, IDB } from '@migration-script-runner/core';

class PostgreSQLHandler implements IDatabaseMigrationHandler<IDB> {
  db: IDB;  // ‚ùå Generic IDB - no PostgreSQL methods visible

  constructor(db: IDB) {
    this.db = db;
  }

  // ... other methods
}
```

#### AFTER (v0.6.0)

```typescript
import { IDatabaseMigrationHandler } from '@migration-script-runner/core';
import { IPostgresDB } from './types';

class PostgreSQLHandler implements IDatabaseMigrationHandler<IPostgresDB> {
  db: IPostgresDB;  // ‚úÖ Typed - full PostgreSQL methods visible

  constructor(db: IPostgresDB) {
    this.db = db;
  }

  // ... other methods
}
```

### Step 3: Type Your Migrations

Add type parameters to migration scripts:

#### BEFORE (v0.5.x)

```typescript
import { IRunnableScript, IMigrationInfo, IDatabaseMigrationHandler } from '@migration-script-runner/core';

const migration: IRunnableScript = {
  async up(db, info, handler) {
    // ‚ùå db is IDB - no database-specific autocomplete
    // ‚ùå Have to cast to access query()
    await (db as any).query('CREATE TABLE users (id SERIAL PRIMARY KEY)');
  },

  async down(db, info, handler) {
    await (db as any).query('DROP TABLE users');
  }
};

export default migration;
```

#### AFTER (v0.6.0)

```typescript
import { IRunnableScript, IMigrationInfo, IDatabaseMigrationHandler } from '@migration-script-runner/core';
import { IPostgresDB } from '../types';

const migration: IRunnableScript<IPostgresDB> = {
  async up(db, info, handler) {
    // ‚úÖ db is IPostgresDB - full autocomplete!
    // ‚úÖ No casting needed
    await db.query('CREATE TABLE users (id SERIAL PRIMARY KEY)');

    // ‚úÖ PostgreSQL-specific features work
    await db.query('CREATE INDEX CONCURRENTLY idx_email ON users(email)');
  },

  async down(db, info, handler) {
    await db.query('DROP TABLE users');
  }
};

export default migration;
```

### Step 4: Type Your Executor

Update the constructor call and add the generic parameter:

#### BEFORE (v0.5.x)

```typescript
import { MigrationScriptExecutor, Config } from '@migration-script-runner/core';

// Old constructor signature
const executor = new MigrationScriptExecutor(handler, config);
```

#### AFTER (v0.6.0)

```typescript
import { MigrationScriptExecutor, Config } from '@migration-script-runner/core';
import { IPostgresDB } from './types';

// New constructor signature with generic type parameter
const executor = new MigrationScriptExecutor<IPostgresDB>({ handler }, config);
// Now executor knows about PostgreSQL-specific types throughout
```

---

## Enhanced Type Guards

v0.6.0 enhances the transaction type guard functions to **preserve your specific database type** while checking for transaction support.

### isImperativeTransactional

#### BEFORE (v0.5.0)

```typescript
import { isImperativeTransactional } from '@migration-script-runner/core';

const db: IPostgresDB = new PostgresDB(pool);

if (isImperativeTransactional(db)) {
  // db is narrowed to ITransactionalDB
  // ‚ùå Lost PostgreSQL-specific methods!
  await db.beginTransaction();
  await (db as any).query('SELECT * FROM users');  // Have to cast!
}
```

#### AFTER (v0.6.0)

```typescript
import { isImperativeTransactional } from '@migration-script-runner/core';

const db: IPostgresDB = new PostgresDB(pool);

if (isImperativeTransactional(db)) {
  // db is now: IPostgresDB & ITransactionalDB
  // ‚úÖ Has BOTH PostgreSQL methods AND transaction methods
  await db.beginTransaction();
  await db.query('SELECT * FROM users');  // ‚úÖ No cast needed!
  await db.commit();
}
```

### isCallbackTransactional

#### BEFORE (v0.5.0)

```typescript
import { isCallbackTransactional } from '@migration-script-runner/core';
import { Transaction } from '@google-cloud/firestore';

const db: IFirestoreDB = new FirestoreDB(firestore);

if (isCallbackTransactional<Transaction>(db)) {
  // db is narrowed to ICallbackTransactionalDB<Transaction>
  // ‚ùå Lost Firestore-specific methods!
  await db.runTransaction(async (tx) => {
    // Have to access firestore instance separately
  });
}
```

#### AFTER (v0.6.0)

```typescript
import { isCallbackTransactional } from '@migration-script-runner/core';
import { Transaction } from '@google-cloud/firestore';

const db: IFirestoreDB = new FirestoreDB(firestore);

if (isCallbackTransactional<IFirestoreDB, Transaction>(db)) {
  // db is now: IFirestoreDB & ICallbackTransactionalDB<Transaction>
  // ‚úÖ Has BOTH Firestore methods AND transaction methods
  await db.runTransaction(async (tx) => {
    const docRef = db.collection('users').doc('user1');  // ‚úÖ Works!
    const doc = await tx.get(docRef);
    tx.update(docRef, { migrated: true });
  });
}
```

---

## Real-World Examples

### PostgreSQL Migration with Full Type Safety

```typescript
// types.ts
import { ITransactionalDB } from '@migration-script-runner/core';
import { Pool, QueryResult } from 'pg';

export interface IPostgresDB extends ITransactionalDB {
  query<T = any>(sql: string, params?: any[]): Promise<QueryResult<T>>;
  copy(sql: string): Promise<void>;
}

// db.ts
export class PostgresDB implements IPostgresDB {
  constructor(private pool: Pool) {}

  async checkConnection(): Promise<boolean> {
    try {
      await this.pool.query('SELECT 1');
      return true;
    } catch {
      return false;
    }
  }

  async beginTransaction(): Promise<void> {
    await this.pool.query('BEGIN');
  }

  async commit(): Promise<void> {
    await this.pool.query('COMMIT');
  }

  async rollback(): Promise<void> {
    await this.pool.query('ROLLBACK');
  }

  async query<T = any>(sql: string, params?: any[]): Promise<QueryResult<T>> {
    return this.pool.query<T>(sql, params);
  }

  async copy(sql: string): Promise<void> {
    const client = await this.pool.connect();
    try {
      const stream = client.query(sql);
      // Handle COPY operation
    } finally {
      client.release();
    }
  }
}

// handler.ts
import { IDatabaseMigrationHandler, ISchemaVersion, IBackup } from '@migration-script-runner/core';
import { IPostgresDB } from './types';

class PostgreSQLHandler implements IDatabaseMigrationHandler<IPostgresDB> {
  db: IPostgresDB;
  schemaVersion: ISchemaVersion<IPostgresDB>;
  backup?: IBackup<IPostgresDB>;

  constructor(db: IPostgresDB, schemaVersion: ISchemaVersion<IPostgresDB>) {
    this.db = db;
    this.schemaVersion = schemaVersion;
  }

  getName(): string {
    return 'PostgreSQL Handler';
  }

  getVersion(): string {
    return '1.0.0';
  }
}

// migration: V1234567890000_create_users_table.ts
import { IRunnableScript, IMigrationInfo, IDatabaseMigrationHandler } from '@migration-script-runner/core';
import { IPostgresDB } from './types';

const migration: IRunnableScript<IPostgresDB> = {
  async up(db, info, handler) {
    // ‚úÖ Full autocomplete and type checking
    await db.query(`
      CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // ‚úÖ PostgreSQL-specific COPY command
    await db.copy('COPY users FROM STDIN');

    // ‚úÖ Concurrent index creation
    await db.query('CREATE INDEX CONCURRENTLY idx_email ON users(email)');
  },

  async down(db, info, handler) {
    await db.query('DROP TABLE IF EXISTS users');
  }
};

export default migration;

// executor.ts
import { MigrationScriptExecutor, Config } from '@migration-script-runner/core';
import { IPostgresDB } from './types';
import { PostgreSQLHandler } from './handler';
import { PostgresDB } from './db';

const db = new PostgresDB(pool);
const handler = new PostgreSQLHandler(db, schemaVersionImpl);
const config = new Config();

const executor = new MigrationScriptExecutor<IPostgresDB>({ handler }, config);
await executor.up();
```

---

## New Feature: Metrics Collection

v0.6.0 introduces **metrics collection** for observability and performance monitoring. This is an **optional** feature that can be adopted at any time.

### Quick Start

Add metrics collectors to track migration performance:

```typescript
import {
  MigrationScriptExecutor,
  ConsoleMetricsCollector,
  JsonMetricsCollector
} from '@migration-script-runner/core';

const executor = new MigrationScriptExecutor<IPostgresDB>({
  handler,
  metricsCollectors: [
    new ConsoleMetricsCollector(),           // Real-time console output
    new JsonMetricsCollector({               // Detailed JSON reports
      filePath: './metrics/migration.json'
    })
  ]
}, config);

await executor.up();
```

**Console output:**
```
[METRICS] Migration started - 3 pending scripts
[METRICS] V1_CreateUsers completed in 823ms
[METRICS] V2_AddEmail completed in 645ms
[METRICS] Migration completed - 3 scripts in 1468ms (success)
```

### Built-in Collectors

v0.6.0 includes four production-ready collectors:

| Collector | Use Case | Configuration |
|:----------|:---------|:--------------|
| **ConsoleMetricsCollector** | Development, debugging | Zero config |
| **LoggerMetricsCollector** | Production, cloud logging | Requires ILogger |
| **JsonMetricsCollector** | Analysis, detailed debugging | File path |
| **CsvMetricsCollector** | Excel, historical tracking | File path |

### When to Use

**Add metrics collection if you:**
- Need to monitor migration performance
- Want to track execution times in production
- Need to debug slow migrations
- Want historical data for analysis
- Need integration with monitoring tools (Datadog, CloudWatch, etc.)

**Skip metrics collection if:**
- You're just starting with MSR
- Your migrations are simple and fast
- You don't need performance tracking

### Learn More

For complete documentation on metrics collection:
- [Metrics Collection Overview](../customization/metrics/)
- [Built-in Collectors](../customization/metrics/)
- [Custom Collectors Guide](../customization/metrics/custom-collectors)

---

## Benefits Summary

### For TypeScript Users

‚úÖ **IDE Autocomplete** - Full IntelliSense for database-specific methods
‚úÖ **Compile-Time Errors** - Catch typos and method errors before runtime
‚úÖ **Refactoring Support** - Safe renames and API changes
‚úÖ **Self-Documenting** - Types show exactly what methods are available
‚úÖ **No More Casting** - Eliminate `as any` and type assertions

### For JavaScript Users

‚úÖ **Better JSDoc** - More accurate autocomplete in VS Code
‚úÖ **Runtime Safety** - Same runtime behavior, better development experience
‚úÖ **Simple Update** - Just update constructor calls, no type annotations needed

---

## Common Patterns

### Pattern 1: Gradual Adoption

You can mix typed and untyped code during migration:

```typescript
// Some migrations with types
const typedMigration: IRunnableScript<IPostgresDB> = { /* ... */ };

// Some without (defaults to IDB)
const untypedMigration: IRunnableScript = { /* ... */ };

// Both work together - adopt incrementally!
```

### Pattern 2: Shared Database Type

Create a shared types file for your entire project:

```typescript
// types/database.ts
import { ITransactionalDB } from '@migration-script-runner/core';

export interface IAppDatabase extends ITransactionalDB {
  query(sql: string): Promise<any>;
  // Add all your database methods here
}

// Use everywhere:
import { IAppDatabase } from './types/database';
const migration: IRunnableScript<IAppDatabase> = { /* ... */ };
```

### Pattern 3: Multiple Database Support

Support multiple databases with union types:

```typescript
import { IPostgresDB, IMySQLDB } from './types';

type SupportedDB = IPostgresDB | IMySQLDB;

const migration: IRunnableScript<SupportedDB> = {
  async up(db, info, handler) {
    // TypeScript knows methods available on BOTH databases
    await db.query('SELECT 1');
  }
};
```

---

## Troubleshooting

### Issue: "Type 'IDB' is missing properties"

**Cause:** Your database class doesn't implement the full interface.

**Solution:** Implement missing methods or use type assertions for custom databases:

```typescript
const executor = new MigrationScriptExecutor<IDB>({ handler }, config);
// Use IDB (base) instead of specific type if not fully implemented
```

### Issue: "Cannot find name 'IPostgresDB'"

**Cause:** Database-specific interfaces are not included in MSR core.

**Solution:** Define your own interfaces:

```typescript
import { IDB } from '@migration-script-runner/core';

interface IPostgresDB extends IDB {
  query(sql: string): Promise<any>;
}
```

### Issue: Autocomplete not working

**Cause:** TypeScript may not infer the generic automatically.

**Solution:** Explicitly specify the type parameter:

```typescript
const migration: IRunnableScript<IPostgresDB> = {
  // Now autocomplete works!
};
```

---

## FAQ

### Q: Do I need to update my v0.5.x code?

**A:** Yes, you must update the `MigrationScriptExecutor` constructor calls to use the new `{ handler }` syntax. This is a 5-minute find-and-replace task. The generic type parameters are optional (they default to `IDB`).

### Q: What if I don't use TypeScript?

**A:** You still need to update the constructor call from `new MigrationScriptExecutor(handler, config)` to `new MigrationScriptExecutor({ handler }, config)`. The generic type parameters are TypeScript-only and don't affect JavaScript users.

### Q: Will this affect runtime performance?

**A:** No. Generic types are TypeScript compile-time features - they're erased at runtime. Zero performance impact.

### Q: Can I use generics with SQL files (.up.sql)?

**A:** SQL migrations don't benefit from generics (they're not TypeScript), but your handler can still be typed.

### Q: Should I type all migrations at once?

**A:** No need. Adopt incrementally - start with new migrations, update old ones as needed.

### Q: Should I use metrics collection?

**A:** It's optional. Add metrics collection if you need to monitor performance, debug slow migrations, or track execution times in production. Start with `ConsoleMetricsCollector` for development, then add `JsonMetricsCollector` or `LoggerMetricsCollector` for production monitoring.

---

## Summary

v0.6.0 adds **generic type parameters** for enhanced type safety and **metrics collection** for observability, with one breaking change:

- üî® **Constructor update required** - Simple 5-minute change from `(handler, config)` to `({ handler }, config?)`
- ‚úÖ **Optional type parameters** - Generic types default to `IDB` and can be adopted incrementally
- ‚úÖ **Optional metrics collection** - Add ConsoleMetricsCollector, JsonMetricsCollector, etc. via `metricsCollectors` array
- ‚úÖ **Better developer experience** - Full autocomplete and compile-time validation
- ‚úÖ **No runtime impact** - Types are compile-time only

**Recommendation:** Update to v0.6.0 and fix constructor calls (quick find-and-replace), then adopt generic types and metrics collection incrementally as needed.

---

## Next Steps

1. **Update package**: `npm install @migration-script-runner/core@^0.6.0`
2. **Update constructor calls**: Change `new MigrationScriptExecutor(handler, config)` to `new MigrationScriptExecutor({ handler }, config)`
3. **Verify tests pass**: `npm test`
4. **Optional**: Define your database interface
5. **Optional**: Add type parameters to new migrations
6. **Optional**: Gradually type existing migrations
7. **Optional**: Add metrics collection for observability

For detailed documentation, see:
- [Database Handler Interface](../api/interfaces/database-handler.html)
- [Runnable Script Interface](../api/interfaces/runnable-script.html)
- [Type Guards](../api/interfaces/transactional-db.html)
- [Metrics Collection](../customization/metrics/)
