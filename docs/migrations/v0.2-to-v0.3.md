---
layout: default
title: v0.2.x → v0.3.0
parent: Migration Guides
nav_order: 3
---

# Migrating from v0.2.x to v0.3.0
{: .no_toc }

Guide for upgrading from MSR v0.2.x to v0.3.0
{: .fs-6 .fw-300 }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Overview

Version 0.3.0 introduces several **breaking changes** focused on improving code clarity and architecture:

1. **Renamed "todo" → "pending"** throughout the codebase for better terminology
2. **Added `ignored` field** to `IScripts` for complete migration state tracking
3. **Removed "Table" suffix** from renderer methods for format-agnostic naming
4. **Extracted MigrationScanner** service for better separation of concerns
5. **Removed deprecated methods** from public interfaces
6. **Separated Config from IDatabaseMigrationHandler** following Single Responsibility Principle (issue #63)

### Breaking Changes

- ❌ `IScripts.todo` → `IScripts.pending`
- ❌ `getTodo()` → `getPending()` (in MigrationScriptSelector)
- ❌ `drawTodoTable()` → `drawPending()` (in IMigrationRenderer)
- ❌ `drawIgnoredTable()` → `drawIgnored()` (in IMigrationRenderer)
- ❌ `drawExecutedTable()` → `drawExecuted()` (in IMigrationRenderer)
- ❌ `renderTodo()` → `renderPending()` (in IRenderStrategy)
- ❌ `IDatabaseMigrationHandler.cfg` property removed
- ❌ Constructor signatures changed: Config now passed as separate parameter
- ❌ `IRenderStrategy.renderMigrated()` `limit` parameter removed (uses `config.displayLimit` internally)
- ✅ **New:** `IScripts.ignored` field added

### Benefits

- ✅ Professional terminology: "pending" aligns with industry standards (Rails, Flyway, Liquibase)
- ✅ Format-agnostic method names: supports ASCII, JSON, and custom formats
- ✅ Complete migration state: `ignored` field provides full visibility
- ✅ Better architecture: Extracted MigrationScanner follows Single Responsibility Principle
- ✅ Cleaner interfaces: Removed deprecated methods
- ✅ Improved separation of concerns: Config separated from database handler
- ✅ Enhanced testability: Config can be managed independently in tests

---

## Migration Steps

### Step 1: Update Package Version

```bash
npm install @migration-script-runner/core@^0.3.0
```

Or with yarn:

```bash
yarn add @migration-script-runner/core@^0.3.0
```

---

### Step 2: Update IScripts References

#### Change 1: Rename `todo` → `pending`

**Before (v0.2.x):**
```typescript
interface IScripts {
    all: MigrationScript[]
    migrated: MigrationScript[]
    todo: MigrationScript[]     // ❌ REMOVED
    executed: MigrationScript[]
}

const scripts = await getScripts();
console.log(`Pending migrations: ${scripts.todo.length}`);
```

**After (v0.3.0):**
```typescript
interface IScripts {
    all: MigrationScript[]
    migrated: MigrationScript[]
    pending: MigrationScript[]   // ✅ NEW
    ignored: MigrationScript[]   // ✅ NEW
    executed: MigrationScript[]
}

const scripts = await getScripts();
console.log(`Pending migrations: ${scripts.pending.length}`);
console.log(`Ignored migrations: ${scripts.ignored.length}`);
```

**Search & Replace:**
```bash
# Find all occurrences
grep -r "scripts\.todo" your-project/

# Replace pattern
scripts.todo → scripts.pending
```

---

### Step 3: Update Renderer Method Names

#### Change 2: Remove "Table" Suffix

If you're calling renderer methods directly:

**Before (v0.2.x):**
```typescript
renderer.drawTodoTable(pendingScripts);
renderer.drawIgnoredTable(ignoredScripts);
renderer.drawExecutedTable(executedScripts);
```

**After (v0.3.0):**
```typescript
renderer.drawPending(pendingScripts);
renderer.drawIgnored(ignoredScripts);
renderer.drawExecuted(executedScripts);
```

**Search & Replace:**
```bash
drawTodoTable     → drawPending
drawIgnoredTable  → drawIgnored
drawExecutedTable → drawExecuted
```

---

### Step 4: Update Custom Renderers

If you implemented a custom renderer, update the interface methods:

**Before (v0.2.x):**
```typescript
export class MyCustomRenderer implements IMigrationRenderer {
    drawFiglet(): void { /* ... */ }
    drawMigrated(scripts: IScripts, number?: number): void { /* ... */ }
    drawTodoTable(scripts: MigrationScript[]): void { /* ... */ }  // ❌ OLD
    drawIgnoredTable(scripts: MigrationScript[]): void { /* ... */ }  // ❌ OLD
    drawExecutedTable(scripts: IMigrationInfo[]): void { /* ... */ }  // ❌ OLD
}
```

**After (v0.3.0):**
```typescript
export class MyCustomRenderer implements IMigrationRenderer {
    drawFiglet(): void { /* ... */ }
    drawMigrated(scripts: IScripts, number?: number): void { /* ... */ }
    drawPending(scripts: MigrationScript[]): void { /* ... */ }  // ✅ NEW
    drawIgnored(scripts: MigrationScript[]): void { /* ... */ }  // ✅ NEW
    drawExecuted(scripts: IMigrationInfo[]): void { /* ... */ }  // ✅ NEW
}
```

---

### Step 5: Update Custom Render Strategies

If you implemented a custom render strategy:

**Before (v0.2.x):**
```typescript
export class MyRenderStrategy implements IRenderStrategy {
    renderBanner(version: string, handlerName: string): void { /* ... */ }
    renderMigrated(scripts: IScripts, handler: IDatabaseMigrationHandler, limit?: number): void { /* ... */ }
    renderTodo(scripts: MigrationScript[]): void { /* ... */ }  // ❌ OLD
    renderExecuted(scripts: IMigrationInfo[]): void { /* ... */ }
    renderIgnored(scripts: MigrationScript[]): void { /* ... */ }
}
```

**After (v0.3.0):**
```typescript
export class MyRenderStrategy implements IRenderStrategy {
    renderBanner(version: string, handlerName: string): void { /* ... */ }
    renderMigrated(scripts: IScripts, handler: IDatabaseMigrationHandler, limit?: number): void { /* ... */ }
    renderPending(scripts: MigrationScript[]): void { /* ... */ }  // ✅ NEW
    renderExecuted(scripts: IMigrationInfo[]): void { /* ... */ }
    renderIgnored(scripts: MigrationScript[]): void { /* ... */ }
}
```

---

### Step 6: Update Service Constructors (Config Separation)

#### Change 4: Pass Config as Separate Parameter

In v0.3.0, `Config` has been separated from `IDatabaseMigrationHandler` following the Single Responsibility Principle. Services now accept config as a separate constructor parameter.

**Before (v0.2.x):**
```typescript
// Config was accessed from handler
handler.cfg = new Config();

// Services only needed handler
const executor = new MigrationScriptExecutor(handler);
const backupService = new BackupService(handler);
const renderer = new MigrationRenderer(handler);
```

**After (v0.3.0):**
```typescript
// Config is now separate
const config = new Config();

// Services accept config as second parameter
const executor = new MigrationScriptExecutor(handler, config);
const backupService = new BackupService(handler, config);
const renderer = new MigrationRenderer(handler, config);
```

**IDatabaseMigrationHandler Interface Change:**
```typescript
// Before (v0.2.x)
interface IDatabaseMigrationHandler {
    getName(): string
    db: IDB
    schemaVersion: ISchemaVersion
    backup: IBackup
    cfg: Config  // ❌ REMOVED
}

// After (v0.3.0)
interface IDatabaseMigrationHandler {
    getName(): string
    db: IDB
    schemaVersion: ISchemaVersion
    backup: IBackup
    // cfg property removed - pass separately to constructors
}
```

**Updated Constructor Signatures:**

| Service | Old Signature | New Signature |
|---------|--------------|---------------|
| `MigrationScriptExecutor` | `(handler)` | `(handler, config, dependencies?)` |
| `BackupService` | `(handler, logger?)` | `(handler, config, logger?)` |
| `MigrationRenderer` | `(handler, strategy?)` | `(handler, config, strategy?)` |
| `MigrationScanner` | `(...)` | `(..., handler, config)` |

**If you have custom handler implementations:**
```typescript
// Before (v0.2.x)
class MyDatabaseHandler implements IDatabaseMigrationHandler {
    cfg: Config;

    constructor(config: Config) {
        this.cfg = config;
    }
}

// After (v0.3.0)
class MyDatabaseHandler implements IDatabaseMigrationHandler {
    // No cfg property

    constructor(config: Config) {
        // Config is managed externally, passed to services
    }
}
```

---

### Step 7: Update Render Strategy Implementations

#### Change 5: Remove `limit` Parameter from `renderMigrated()`

Render strategies now use `config.displayLimit` internally instead of receiving it as a parameter.

**Before (v0.2.x):**
```typescript
class MyRenderStrategy implements IRenderStrategy {
    renderMigrated(scripts: IScripts, config: Config, limit?: number): void {
        const displayLimit = limit || config.displayLimit;
        // Use displayLimit...
    }
}
```

**After (v0.3.0):**
```typescript
class MyRenderStrategy implements IRenderStrategy {
    renderMigrated(scripts: IScripts, config: Config): void {
        // Use config.displayLimit directly
        const displayLimit = config.displayLimit;
        // ...
    }
}
```

**Why this change?**
- Eliminates redundancy - config already has the limit
- Simplifies the interface
- More consistent - other render methods don't have extra parameters

---

### Step 8: Update MigrationResult Handling

The `IMigrationResult.ignored` field is now properly populated:

**Before (v0.2.x):**
```typescript
const result = await executor.migrate();

console.log(`Executed: ${result.executed.length}`);
console.log(`Migrated: ${result.migrated.length}`);
// result.ignored was always empty
```

**After (v0.3.0):**
```typescript
const result = await executor.migrate();

console.log(`Executed: ${result.executed.length}`);
console.log(`Migrated: ${result.migrated.length}`);
console.log(`Ignored: ${result.ignored.length}`);  // ✅ Now populated!

// Show which migrations were skipped
if (result.ignored.length > 0) {
    console.warn('Ignored migrations (older than last executed):');
    result.ignored.forEach(script => {
        console.warn(`  - ${script.name} (timestamp: ${script.timestamp})`);
    });
}
```

---

## Understanding the New Architecture

### MigrationScanner Service

v0.3.0 extracts migration state gathering into a dedicated `MigrationScanner` service:

```typescript
import { MigrationScanner } from '@migration-script-runner/core';

// The scanner gathers complete migration state
const scanner = new MigrationScanner(
    migrationService,
    schemaVersionService,
    selector,
    handler
);

const scripts = await scanner.scan();
// Returns: { all, migrated, pending, ignored, executed }
```

**Benefits:**
- **Single Responsibility:** Separation of concerns - gathering state vs. executing migrations
- **Testability:** Easy to test scanning logic independently
- **Reusability:** Can use scanner in other contexts (reporting, analytics)
- **Performance:** Parallel execution of database and filesystem queries

---

## Common Migration Patterns

### Pattern 1: Accessing Pending Migrations

**Before (v0.2.x):**
```typescript
const result = await executor.migrate();
const pendingCount = result.executed.length; // Only shows what was executed
```

**After (v0.3.0):**
```typescript
const result = await executor.migrate();
const pendingCount = result.executed.length;
const ignoredCount = result.ignored.length;

console.log(`Executed: ${pendingCount}, Ignored: ${ignoredCount}`);
```

### Pattern 2: Custom Rendering with JSON

**Before (v0.2.x):**
```typescript
const output = {
    todo: scripts.todo.map(s => ({ name: s.name, timestamp: s.timestamp }))
};
```

**After (v0.3.0):**
```typescript
const output = {
    pending: scripts.pending.map(s => ({ name: s.name, timestamp: s.timestamp })),
    ignored: scripts.ignored.map(s => ({ name: s.name, timestamp: s.timestamp }))
};
```

### Pattern 3: Variable Naming

**Before (v0.2.x):**
```typescript
const todo = scripts.todo;
todo.forEach(script => {
    console.log(`Will execute: ${script.name}`);
});
```

**After (v0.3.0):**
```typescript
const pending = scripts.pending;
pending.forEach(script => {
    console.log(`Will execute: ${script.name}`);
});
```

### Pattern 4: Service Initialization with Config

**Before (v0.2.x):**
```typescript
// Handler contained config
handler.cfg = new Config();
handler.cfg.folder = './migrations';
handler.cfg.displayLimit = 10;

// Services accessed config from handler
const executor = new MigrationScriptExecutor(handler);
const backupService = new BackupService(handler);
const renderer = new MigrationRenderer(handler);
```

**After (v0.3.0):**
```typescript
// Config is separate
const config = new Config();
config.folder = './migrations';
config.displayLimit = 10;

// Services accept config as parameter
const executor = new MigrationScriptExecutor(handler, config);
const backupService = new BackupService(handler, config);
const renderer = new MigrationRenderer(handler, config);
```

### Pattern 5: Custom Handler Implementation

**Before (v0.2.x):**
```typescript
class PostgresHandler implements IDatabaseMigrationHandler {
    cfg: Config;
    db: IDB;
    schemaVersion: ISchemaVersion;
    backup: IBackup;

    constructor(connectionString: string, config: Config) {
        this.cfg = config;
        this.db = new PostgresDB(connectionString);
        // ...
    }

    getName(): string {
        return 'PostgreSQL';
    }
}

// Usage
const handler = new PostgresHandler(connStr, config);
const executor = new MigrationScriptExecutor(handler);
```

**After (v0.3.0):**
```typescript
class PostgresHandler implements IDatabaseMigrationHandler {
    // No cfg property
    db: IDB;
    schemaVersion: ISchemaVersion;
    backup: IBackup;

    constructor(connectionString: string) {
        this.db = new PostgresDB(connectionString);
        // ...
    }

    getName(): string {
        return 'PostgreSQL';
    }
}

// Usage - config passed separately
const config = new Config();
const handler = new PostgresHandler(connStr);
const executor = new MigrationScriptExecutor(handler, config);
```

### Pattern 6: Testing with Config

**Before (v0.2.x):**
```typescript
it('should execute migrations', async () => {
    const handler = createMockHandler();
    handler.cfg = new Config();
    handler.cfg.folder = './test-migrations';

    const executor = new MigrationScriptExecutor(handler);
    await executor.migrate();
});
```

**After (v0.3.0):**
```typescript
it('should execute migrations', async () => {
    const handler = createMockHandler();
    const config = new Config();
    config.folder = './test-migrations';

    const executor = new MigrationScriptExecutor(handler, config);
    await executor.migrate();
});
```

---

## Automated Migration

### Using sed (Unix/Linux/macOS)

```bash
# Navigate to your project
cd your-project/

# Backup first!
git add .
git commit -m "Before MSR v0.4 upgrade"

# Replace scripts.todo → scripts.pending
find . -type f \( -name "*.ts" -o -name "*.js" \) -exec sed -i '' 's/scripts\.todo/scripts.pending/g' {} +

# Replace method names
find . -type f \( -name "*.ts" -o -name "*.js" \) -exec sed -i '' 's/drawTodoTable/drawPending/g' {} +
find . -type f \( -name "*.ts" -o -name "*.js" \) -exec sed -i '' 's/drawIgnoredTable/drawIgnored/g' {} +
find . -type f \( -name "*.ts" -o -name "*.js" \) -exec sed -i '' 's/drawExecutedTable/drawExecuted/g' {} +
find . -type f \( -name "*.ts" -o -name "*.js" \) -exec sed -i '' 's/renderTodo/renderPending/g' {} +

# Verify changes
git diff
```

### Using PowerShell (Windows)

```powershell
# Backup first!
git add .
git commit -m "Before MSR v0.4 upgrade"

# Replace patterns
Get-ChildItem -Recurse -Include *.ts,*.js | ForEach-Object {
    (Get-Content $_) | ForEach-Object {
        $_ -replace 'scripts\.todo', 'scripts.pending' `
           -replace 'drawTodoTable', 'drawPending' `
           -replace 'drawIgnoredTable', 'drawIgnored' `
           -replace 'drawExecutedTable', 'drawExecuted' `
           -replace 'renderTodo', 'renderPending'
    } | Set-Content $_
}
```

---

## TypeScript Compilation Errors

After upgrading, you may see TypeScript errors. Here's how to fix them:

### Error 1: Property 'todo' does not exist

```
Property 'todo' does not exist on type 'IScripts'. Did you mean 'pending'?
```

**Fix:** Replace `scripts.todo` with `scripts.pending`

### Error 2: Property 'drawTodoTable' does not exist

```
Property 'drawTodoTable' does not exist on type 'IMigrationRenderer'.
```

**Fix:** Replace `drawTodoTable` with `drawPending`

### Error 3: Type is missing properties

```
Type 'MyRenderer' is missing properties 'drawPending', 'drawIgnored', 'drawExecuted'
```

**Fix:** Implement the new method names in your custom renderer

### Error 4: Property 'cfg' does not exist on type 'IDatabaseMigrationHandler'

```
Property 'cfg' does not exist on type 'IDatabaseMigrationHandler'.
```

**Fix:** Remove `handler.cfg` references and pass config as a separate parameter to service constructors

**Before:**
```typescript
const config = handler.cfg;
const executor = new MigrationScriptExecutor(handler);
```

**After:**
```typescript
const config = new Config();
const executor = new MigrationScriptExecutor(handler, config);
```

### Error 5: Expected 2 arguments, but got 1

```
Expected 2 arguments, but got 1.
```

**Context:** Occurs when instantiating services like `MigrationScriptExecutor`, `BackupService`, `MigrationRenderer`

**Fix:** Add config as the second parameter

**Before:**
```typescript
new MigrationScriptExecutor(handler)
new BackupService(handler, logger)
new MigrationRenderer(handler, strategy)
```

**After:**
```typescript
new MigrationScriptExecutor(handler, config)
new BackupService(handler, config, logger)
new MigrationRenderer(handler, config, strategy)
```

### Error 6: Argument of type '(scripts: IScripts, config: Config, limit?: number)' is not assignable

```
Types of parameters 'limit' and 'limit' are incompatible.
Type 'undefined' is not assignable to type 'number | undefined'.
```

**Context:** Occurs in custom render strategy implementations

**Fix:** Remove the `limit` parameter from `renderMigrated()` method

**Before:**
```typescript
renderMigrated(scripts: IScripts, config: Config, limit?: number): void {
    const displayLimit = limit || config.displayLimit;
}
```

**After:**
```typescript
renderMigrated(scripts: IScripts, config: Config): void {
    const displayLimit = config.displayLimit;
}
```

---

## Testing

### Before (v0.2.x)

```typescript
it('should get todo scripts', () => {
    const todo = selector.getTodo(migrated, all);
    expect(todo).to.have.lengthOf(3);
});
```

### After (v0.3.0)

```typescript
it('should get pending scripts', () => {
    const pending = selector.getPending(migrated, all);
    expect(pending).to.have.lengthOf(3);
});
```

---

## Troubleshooting

### Issue: TypeScript Errors After Upgrade

**Problem:** Getting compilation errors about missing properties.

**Solution:** Make sure you've updated all references:
1. `scripts.todo` → `scripts.pending`
2. Method names (see Step 3 above)
3. Custom renderer implementations

### Issue: Tests Failing

**Problem:** Tests fail with "property 'todo' does not exist"

**Solution:** Update test code to use new naming:
```bash
# Search for test files
grep -r "todo" test/

# Update them using the patterns above
```

### Issue: JSON Output Changed

**Problem:** JSON output format changed from `{todo: [...]}` to `{pending: [...]}`

**Solution:** This is expected. Update any code that parses the JSON output:
```typescript
// Before
const data = JSON.parse(output);
data.todo.forEach(...);

// After
const data = JSON.parse(output);
data.pending.forEach(...);
```

---

## Rollback Plan

If you need to rollback to v0.2.x:

```bash
npm install @migration-script-runner/core@^0.2.0
```

Then restore your code using git:

```bash
git checkout HEAD -- .
```

---

## New Features in v0.3.0

In addition to the breaking changes, v0.3.0 includes:

### 1. Complete Migration State Tracking

The `ignored` field now provides complete visibility:

```typescript
const result = await executor.migrate();

// Full visibility into migration state
console.log('Total scripts:', result.migrated.length + result.executed.length);
console.log('Newly executed:', result.executed.length);
console.log('Skipped (too old):', result.ignored.length);
```

### 2. Improved Architecture

- **MigrationScanner** service extracts state gathering logic
- Better testability and separation of concerns
- Parallel execution of database and filesystem queries for performance

### 3. Professional Terminology

- Aligns with industry standards (Rails, Flyway, Liquibase use "pending")
- More intuitive for developers familiar with migration tools

### 4. Sub-folder Support for Migration Scripts

v0.3.0 introduces **recursive sub-folder scanning**, allowing you to organize migrations by feature, module, or version while maintaining timestamp-based execution order.

**Key Features:**
- ✅ Organize migrations in sub-folders by feature, module, or version
- ✅ Migrations always execute in timestamp order regardless of folder location
- ✅ Enabled by default with `config.recursive = true`
- ✅ Hidden files and folders (starting with `.`) are automatically excluded
- ✅ Supports deep nesting for complex project structures

**Example Structure:**
```
migrations/
├── users/
│   ├── V202501220100_create_users_table.ts
│   └── V202501230200_add_user_roles.ts
├── auth/
│   └── V202501220150_create_sessions_table.ts
└── products/
    └── V202501240100_create_products_table.ts
```

**Execution Order:** Always by timestamp
1. `V202501220100_create_users_table.ts` (users/)
2. `V202501220150_create_sessions_table.ts` (auth/)
3. `V202501230200_add_user_roles.ts` (users/)
4. `V202501240100_create_products_table.ts` (products/)

**Configuration:**
```typescript
const config = new Config();

// Recursive mode (default) - scan all sub-folders
config.recursive = true;

// Single-folder mode - scan only root folder
config.recursive = false;
```

**No Migration Required:** Sub-folder support is opt-in via configuration. Existing flat structures continue to work without changes.

### 5. beforeMigrate File for Database Setup

v0.3.0 introduces support for a special `beforeMigrate.ts` (or `.js`) file that executes **before** MSR scans for pending migrations. This file-based approach is similar to Flyway's `beforeMigrate.sql`.

**Key Features:**
- ✅ File-based: Create `beforeMigrate.ts` in your migrations folder
- ✅ Executes **before** migration scanning (can reset/erase database)
- ✅ Uses same `IRunnableScript` interface as regular migrations
- ✅ NOT saved to schema version table
- ✅ Configurable filename via `config.beforeMigrateName`
- ✅ Can be disabled by setting `config.beforeMigrateName = null`
- ✅ Completely optional - maintains backward compatibility

**File Location:**
```
migrations/
├── beforeMigrate.ts          # ← Special setup script
├── V202501010001_init.ts
└── V202501020001_users.ts
```

**Example: beforeMigrate.ts**
```typescript
// migrations/beforeMigrate.ts
import fs from 'fs';
import {IRunnableScript, IMigrationInfo, IDatabaseMigrationHandler, IDB} from 'migration-script-runner';

export default class BeforeMigrate implements IRunnableScript {
  async up(
    db: IDB,
    info: IMigrationInfo,
    handler: IDatabaseMigrationHandler
  ): Promise<string> {
    // Data seeding - load production snapshot for development/testing
    if (process.env.NODE_ENV === 'development') {
      const snapshot = fs.readFileSync('./snapshots/prod_snapshot.sql', 'utf8');
      console.log('Loading production snapshot...');
      await (db as any).query(snapshot);
      console.log('✅ Production snapshot loaded');
    }

    // Fresh database setup - create extensions
    const tables = await (db as any).query(`
      SELECT COUNT(*) as count
      FROM information_schema.tables
      WHERE table_schema = 'public'
    `);

    if (tables[0].count === 0) {
      await (db as any).query('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"');
      await (db as any).query('CREATE EXTENSION IF NOT EXISTS "pg_trgm"');
    }

    // Environment-specific setup
    if (process.env.NODE_ENV === 'test') {
      await (db as any).query('SET statement_timeout = 0');
    }

    return 'beforeMigrate setup completed';
  }
}
```

**Configuration:**
```typescript
import { Config } from 'migration-script-runner';

const config = new Config();

// Default: looks for beforeMigrate.ts or beforeMigrate.js
config.beforeMigrateName = 'beforeMigrate';

// Custom name: looks for setup.ts or setup.js
config.beforeMigrateName = 'setup';

// Disable feature entirely
config.beforeMigrateName = null;
```

**When to Use:**
- Loading production snapshots or test data **before** migrations
- Completely resetting/erasing the database (runs before scan)
- Creating database extensions on fresh setups
- Setting environment-specific parameters
- Validating database version or prerequisites

**Execution Timing:**
```
1. Create backup
2. Initialize schema version table
3. Execute beforeMigrate.ts  ← Runs BEFORE scan
4. Scan for pending migrations
5. Execute pending migrations
6. Delete backup
```

**No Migration Required:** `beforeMigrate.ts` is optional. Projects without it continue to work without changes.

---

## FAQ

**Q: Is this a breaking change?**
A: Yes. Multiple breaking changes to interfaces and field names.

**Q: Will my migration scripts break?**
A: No. Migration scripts themselves are not affected. Only the code that uses MSR's API needs updating.

**Q: Can I use v0.2.x and v0.3.0 side by side?**
A: No. Choose one version for your project.

**Q: How long will v0.2.x be supported?**
A: v0.2.x will receive bug fixes for 6 months after v0.3.0 release. New features will only be added to v0.3.0 and later.

**Q: Do I need to update my database?**
A: No. The database schema and migration scripts are unchanged.

**Q: What about the ignored migrations?**
A: They were always being calculated, just not exposed. Now you can see them in `result.ignored`.

**Q: Why was Config separated from IDatabaseMigrationHandler?**
A: Following the Single Responsibility Principle - the handler should manage database operations, not application configuration. This improves testability, reduces coupling, and makes the architecture cleaner.

**Q: Do I need to update my handler implementation?**
A: Yes, if your handler implements `IDatabaseMigrationHandler`, remove the `cfg` property. Config is now passed separately to services that need it.

**Q: Will this affect my tests?**
A: Yes, you'll need to update test code to pass config as a separate parameter to service constructors. This actually makes tests easier to write since config can be managed independently.

**Q: Can I still access config in services?**
A: Yes, services that need config accept it as a constructor parameter and store it internally. The change is only about where config lives, not how it's used.

---

## Support

If you encounter issues during migration:

- [GitHub Issues](https://github.com/migration-script-runner/msr-core/issues)
- [API Reference](../api/)
- [Architecture Guide](../architecture)
- [Custom Rendering Guide](../guides/custom-rendering)

---

**Released:** v0.3.0 (TBD)
