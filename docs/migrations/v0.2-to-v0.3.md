---
layout: default
title: v0.2.x → v0.3.0
parent: Migration Guides
nav_order: 2
---

# Migrating from v0.2.x to v0.3.0
{: .no_toc }

Guide for upgrading from MSR v0.2.x to v0.3.x
{: .fs-6 .fw-300 }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Overview

Version 0.3.0 introduces a **breaking change** to enable library usage in long-running applications. The `migrate()` method now returns a result object instead of calling `process.exit()` internally.

### Breaking Changes

- ✅ `migrate()` now returns `Promise<IMigrationResult>` instead of `Promise<void>`
- ✅ `process.exit()` is no longer called automatically
- ✅ Caller controls process lifecycle

### Benefits

- ✅ Safe to use in web servers (Express, NestJS, Fastify, etc.)
- ✅ Safe to use in background workers and long-running processes
- ✅ Structured error handling with detailed results
- ✅ Better testability (no need to mock `process.exit`)
- ✅ Backward compatible pattern available for CLI usage

---

## Migration Steps

### Step 1: Update Package Version

```bash
npm install @migration-script-runner/core@^0.3.0
```

Or with yarn:

```bash
yarn add @migration-script-runner/core@^0.3.0
```

---

### Step 2: Update Your Code

#### Before (v0.2.x)

```typescript
import { MigrationScriptExecutor } from '@migration-script-runner/core';

const executor = new MigrationScriptExecutor(handler);

// This would exit the process with code 0 or 1
await executor.migrate();

// Code after this line would never execute
console.log('This never runs');
```

#### After (v0.3.x) - Library Usage

For applications that should continue running after migrations:

```typescript
import { MigrationScriptExecutor, IMigrationResult } from '@migration-script-runner/core';

const executor = new MigrationScriptExecutor(handler);

// Now returns a result object
const result: IMigrationResult = await executor.migrate();

if (result.success) {
  console.log(`✅ Successfully executed ${result.executed.length} migrations`);
  // Continue with application startup
  await startServer();
} else {
  console.error('❌ Migration failed:', result.errors);
  // Handle error gracefully
  await notifyAdmins(result.errors);
  process.exit(1);
}
```

#### After (v0.3.x) - CLI Usage

For standalone migration scripts that should exit on completion:

```typescript
import { MigrationScriptExecutor } from '@migration-script-runner/core';

const executor = new MigrationScriptExecutor(handler);

// Get result and control exit
const result = await executor.migrate();
process.exit(result.success ? 0 : 1);
```

---

## Understanding IMigrationResult

The new `IMigrationResult` interface provides structured information about the migration run:

```typescript
interface IMigrationResult {
  success: boolean;           // Overall success status
  executed: MigrationScript[]; // Migrations run in this execution
  migrated: MigrationScript[]; // All previously executed migrations
  ignored: MigrationScript[];  // Migrations skipped (older than last executed)
  errors?: Error[];           // Errors if migration failed
}
```

### Accessing Result Properties

```typescript
const result = await executor.migrate();

// Check success
if (result.success) {
  console.log('Migration succeeded');
}

// Get execution details
console.log(`Executed: ${result.executed.length}`);
console.log(`Total migrated: ${result.migrated.length}`);
console.log(`Ignored: ${result.ignored.length}`);

// Handle errors
if (!result.success && result.errors) {
  result.errors.forEach(err => {
    console.error('Error:', err.message);
    console.error('Stack:', err.stack);
  });
}
```

---

## Common Migration Patterns

### Pattern 1: Express.js Application

**Before (v0.2.x):**
```typescript
// This would kill the Express server after migrations
await executor.migrate();
app.listen(3000); // Never reached
```

**After (v0.3.x):**
```typescript
const result = await executor.migrate();

if (result.success) {
  app.listen(3000, () => {
    console.log(`Server started after ${result.executed.length} migrations`);
  });
} else {
  console.error('Migration failed, not starting server');
  process.exit(1);
}
```

### Pattern 2: NestJS Application

**Before (v0.2.x):**
```typescript
async function bootstrap() {
  await executor.migrate(); // Would terminate process
  const app = await NestFactory.create(AppModule); // Never reached
  await app.listen(3000);
}
```

**After (v0.3.x):**
```typescript
async function bootstrap() {
  const result = await executor.migrate();

  if (!result.success) {
    console.error('Migration failed:', result.errors);
    process.exit(1);
  }

  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application started with ${result.migrated.length} total migrations`);
}
```

### Pattern 3: Background Worker

**Before (v0.2.x):**
```typescript
// Worker would be terminated after migrations
await executor.migrate();
startWorkerLoop(); // Never reached
```

**After (v0.3.x):**
```typescript
const result = await executor.migrate();

if (result.success) {
  console.log('Migrations complete, starting worker');
  startWorkerLoop();
} else {
  console.error('Migration failed, worker not started');
  await sendAlert(result.errors);
  process.exit(1);
}
```

### Pattern 4: CLI Script (Backward Compatible)

**v0.2.x behavior can be maintained:**
```typescript
// Single line change to maintain v0.2.x behavior
const result = await executor.migrate();
process.exit(result.success ? 0 : 1);
```

---

## Error Handling

### Before (v0.2.x)

```typescript
try {
  await executor.migrate();
  // Success case never reached due to process.exit(0)
} catch (error) {
  // Error handling happened internally
  // Process would exit with code 1
}
```

### After (v0.3.x)

```typescript
// No try-catch needed - errors are in result object
const result = await executor.migrate();

if (result.success) {
  console.log('Success!');
  logToAnalytics('migration_success', {
    count: result.executed.length
  });
} else {
  console.error('Failed:', result.errors);
  await sendToErrorTracking(result.errors);
  await rollbackDeployment();
  process.exit(1);
}
```

---

## Testing

### Before (v0.2.x)

```typescript
// Had to stub process.exit
const exitStub = sinon.stub(process, 'exit');

await executor.migrate();

expect(exitStub).to.have.been.calledWith(0);
exitStub.restore();
```

### After (v0.3.x)

```typescript
// No stubbing needed - check result directly
const result = await executor.migrate();

expect(result.success).to.be.true;
expect(result.executed).to.have.length(5);
expect(result.errors).to.be.undefined;
```

---

## Troubleshooting

### Issue: Application Exits After Migrations

**Problem:** Your application still exits after migrations complete.

**Cause:** You're calling `process.exit()` when you shouldn't be.

**Solution:** Remove `process.exit()` calls for library usage:

```typescript
// ❌ Wrong - exits the application
const result = await executor.migrate();
process.exit(result.success ? 0 : 1);

// ✅ Correct - continues running
const result = await executor.migrate();
if (result.success) {
  await startApp();
} else {
  console.error(result.errors);
  process.exit(1); // Only exit on failure
}
```

### Issue: TypeScript Type Errors

**Problem:** TypeScript complains about return type.

**Solution:** Import `IMigrationResult`:

```typescript
import { IMigrationResult } from '@migration-script-runner/core';

const result: IMigrationResult = await executor.migrate();
```

### Issue: Tests Failing

**Problem:** Tests fail after upgrade.

**Solution:** Update test assertions to check result object:

```typescript
// Before
await executor.migrate();
// No assertion possible

// After
const result = await executor.migrate();
expect(result.success).to.be.true;
```

---

## Rollback Plan

If you need to rollback to v0.2.x:

```bash
npm install @migration-script-runner/core@^0.2.0
```

Your old code will work without changes in v0.2.x.

---

## New Features in v0.3.0

In addition to the breaking change, v0.3.0 includes:

### 1. Enhanced Logging System

v0.3.0 introduces a flexible logging system with multiple built-in logger implementations and support for custom loggers.

#### New Built-in Loggers

Four logger implementations are now available:

```typescript
import { ConsoleLogger, SilentLogger, FileLogger, CompositeLogger } from '@migration-script-runner/core';

// Console output (default)
const consoleLogger = new ConsoleLogger();

// Suppress all output (ideal for testing)
const silentLogger = new SilentLogger();

// File-based logging with automatic rotation
const fileLogger = new FileLogger({
    logPath: '/var/log/migrations.log',
    maxFileSize: 10 * 1024 * 1024, // 10MB
    maxFiles: 10
});

// Multi-destination logging (console + file)
const compositeLogger = new CompositeLogger([
    new ConsoleLogger(),
    new FileLogger({ logPath: '/var/log/migrations.log' })
]);
```

#### Using Loggers

All services now accept an optional logger parameter:

```typescript
import { MigrationService, FileLogger } from '@migration-script-runner/core';

const logger = new FileLogger({
    logPath: '/var/log/migrations.log',
    maxFileSize: 10 * 1024 * 1024,
    maxFiles: 10
});

const service = new MigrationService(logger);
await service.executeMigrations(config);
```

#### Custom Logger Implementation

Implement the `ILogger` interface for custom logging destinations:

```typescript
import { ILogger } from '@migration-script-runner/core';

class CloudWatchLogger implements ILogger {
    info(message: string, ...args: unknown[]): void {
        // Send to CloudWatch
    }

    warn(message: string, ...args: unknown[]): void {
        // Send to CloudWatch
    }

    error(message: string, ...args: unknown[]): void {
        // Send to CloudWatch
    }

    debug(message: string, ...args: unknown[]): void {
        // Send to CloudWatch
    }

    log(message: string, ...args: unknown[]): void {
        // Send to CloudWatch
    }
}

const logger = new CloudWatchLogger();
const service = new MigrationService(logger);
```

#### FileLogger Features

The new `FileLogger` includes enterprise-grade features:

- **Automatic rotation** based on file size
- **Configurable retention** with backup file limits
- **Optional timestamps** with custom formats
- **Utility methods** for log management (`getFileSize()`, `getLogFiles()`, `clearLogs()`)

```typescript
const logger = new FileLogger({
    logPath: '/var/log/myapp/migrations.log',
    maxFileSize: 50 * 1024 * 1024,  // 50MB
    maxFiles: 30,                    // Keep 30 backup files
    includeTimestamp: true
});

// Check log file size
const size = logger.getFileSize();
console.log(`Current log: ${(size / 1024 / 1024).toFixed(2)} MB`);

// List all log files (current + rotated)
const files = logger.getLogFiles();
console.log(`Total log files: ${files.length}`);

// Clear all logs
logger.clearLogs();
```

#### SilentLogger for Testing

Use `SilentLogger` to keep test output clean:

```typescript
import { MigrationService, SilentLogger } from '@migration-script-runner/core';
import { expect } from 'chai';

describe('MigrationService', () => {
    it('should execute migrations successfully', async () => {
        // No console output during tests
        const logger = new SilentLogger();
        const service = new MigrationService(logger);

        const result = await service.executeMigrations(config);
        expect(result.success).to.be.true;
    });
});
```

#### Documentation

For complete logging documentation, see:
- [Logger Implementations](../loggers/) - Detailed guides for each logger
- [ConsoleLogger](../loggers/console-logger) - Default console output
- [SilentLogger](../loggers/silent-logger) - Suppress all output
- [FileLogger](../loggers/file-logger) - File-based logging with rotation
- [CompositeLogger](../loggers/composite-logger) - Multi-destination logging
- [Cloud Logger Guide](../loggers/cloud-logger-guide) - Guide for implementing cloud logging services
- [Custom Logging Guide](../guides/custom-logging) - Create your own loggers

### 2. Dependency Injection Support

v0.3.0 introduces comprehensive dependency injection support for testing and customization.

#### Constructor Change

The `MigrationScriptExecutor` constructor signature has changed:

**Before (v0.2.x):**
```typescript
const executor = new MigrationScriptExecutor(handler, logger);
```

**After (v0.3.x):**
```typescript
// Default behavior (backward compatible)
const executor = new MigrationScriptExecutor(handler);

// With custom logger
const executor = new MigrationScriptExecutor(handler, {
    logger: new FileLogger({ logPath: '/var/log/migrations.log' })
});

// With custom services for testing
const executor = new MigrationScriptExecutor(handler, {
    backupService: mockBackupService,
    schemaVersionService: mockSchemaVersionService,
    consoleRenderer: mockRenderer,
    migrationService: mockMigrationService,
    logger: new SilentLogger()
});
```

#### Available Dependencies

All dependencies are optional with sensible defaults:

```typescript
interface IMigrationExecutorDependencies {
    backupService?: IBackupService;
    schemaVersionService?: ISchemaVersionService;
    consoleRenderer?: IConsoleRenderer;
    migrationService?: IMigrationService;
    logger?: ILogger;
}
```

#### Testing Example

```typescript
import { MigrationScriptExecutor, SilentLogger } from '@migration-script-runner/core';

describe('MigrationScriptExecutor', () => {
    it('should execute migrations', async () => {
        const executor = new MigrationScriptExecutor(handler, {
            logger: new SilentLogger()
        });

        const result = await executor.migrate();
        expect(result.success).to.be.true;
    });
});
```

### 3. Structured Migration Results

Access detailed information about migration execution:

```typescript
const result = await executor.migrate();
console.log('Executed:', result.executed.map(s => s.name));
console.log('Ignored:', result.ignored.map(s => s.name));
```

### 3. Better Error Information

Errors are now structured and accessible:

```typescript
if (!result.success) {
  result.errors?.forEach(error => {
    logger.error({
      message: error.message,
      stack: error.stack,
      type: error.constructor.name
    });
  });
}
```

### 4. Integration-Friendly

Safe to use in:
- ✅ Web servers (Express, Koa, Fastify, NestJS)
- ✅ GraphQL servers (Apollo Server, Mercurius)
- ✅ Background workers (Bull, BullMQ, Agenda)
- ✅ Serverless functions (with proper error handling)
- ✅ Desktop applications (Electron)
- ✅ CLI tools (with explicit process.exit control)

---

## FAQ

**Q: Is this a breaking change?**
A: Yes. The `migrate()` method now returns `Promise<IMigrationResult>` instead of `Promise<void>`, and no longer calls `process.exit()`.

**Q: Will my code break?**
A: If you're using `await executor.migrate()` without handling the result, your application will continue running instead of exiting. You'll need to add explicit process control.

**Q: Can I maintain the old behavior?**
A: Yes! Simply add `process.exit(result.success ? 0 : 1)` after calling `migrate()`.

**Q: Do I need to update my migration scripts?**
A: No. Migration scripts themselves are not affected. Only the code that calls `executor.migrate()` needs updating.

**Q: What about the `list()` method?**
A: The `list()` method is unchanged. It still returns `Promise<void>` and displays migration status.

**Q: Will this affect my CI/CD pipeline?**
A: Only if you're running migrations without proper exit codes. Update your migration runner to call `process.exit()` based on the result.

---

## Support

If you encounter issues during migration:

- [GitHub Issues](https://github.com/migration-script-runner/msr-core/issues)
- [API Reference](../api/)
- [Getting Started Guide](../getting-started)

---

**Released:** v0.3.0 (2025-01-23)
**Previous Version:** [v0.1 to v0.2 Migration Guide](v0.1-to-v0.2)
